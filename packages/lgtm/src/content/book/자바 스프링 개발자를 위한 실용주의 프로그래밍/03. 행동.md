TDA 원칙은 객체를 행동하게 만듭니다.
그리고 TDA 원칙이 객체를 행동하게 만든다고 말하는 이유는 간단하다.
'묻지 말고 시켜라'라는 말 자체가 객체에 어떤 행동을 하라고 조언하는 것이기 때문이다.

TDA 원칙은 수동적인 객체를 능동적인 객체로 바꾸는 방법이다.

객체지향 관점에서 객체는 서로 협력하는 존재다. 
협력을 하려면 상대방에게 행동을 요구할 수 있어야 합니다.
따라서 행동 위주의 사고를 하는 편이 객체지향에서는 훨씬 유리하다고 볼 수 있는 것입니다.

객체를 구분 짓는 요인은 데이터가 아닙니다. 행동입니다. 
우리는 객체를 만들 때 데이터보다는 행동에 집중해야 합니다.
데이터가 객체를 결정하지 않습니다. 행동이 객체를 결정합니다.

데이터로는 객체를 정의하기 어렵지만 행동을 보면 객체를 정의하기 쉽기 때문입니다.

> [!NOTE]  
> **행동과 역할**  
> 여기서 하나 더 주목할 것이 있다. 행동을 먼저 고민했더니 Car나 Bicycle 같은 구체적인 이름보다
> Vehicle(탈것)이라는 역할이 나왔다는 것이다.
> 행동을 고민하는 것은 자연스럽게 역할을 고민하게 만든다. 따라서 어떤 행동을 할 수 있는지가
> 곧 역할을 만든다. 그리고 이러한 역할이 모여 객체를 정의하는 것이다.


## 덕 타이핑

덕 타이핑의 개념은 덕 테스트에서 유래했습니다.

> [!NOTE]  
> 덕 테스트: 만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거리는 소리를 낸다면 나는 그 새를 오리라고 부를 것이다.

```ts title="걷고 수영하고 꽥꽥거리는 Duck"
class Duck {
    walk() {
    }

    swim() {
    }

    quackquack() {
    }
}

class UnknownBird {
    #age: number;

    walk() {
    }

    swim() {
    }

    quackquack() {
    }
}

const duck: Duck = new UnknownBird();
```

이것이 가능한 이유는 타입스크립트가 행동이 같은 두 클래스를 같은 클래스로 보겠다는 덕 타이핑의 개념을 지원하기 때문이다. 알 수 없는 새(UnknownBird)가 어떤 새인지는 정확히 모르겠지만 그 새가 오리처럼 걷고 수영하고 꽥꽥거리므로 그냥 오리(Duck)라고 봐도 된다는 것이다.

자바 개발자의 상식에서 벗어나 '행동이 같으면 같은 클래스로 보겠다'라는 덕 타이핑의 개념이 다른 언어에서는 
어떻게 구현됐는지를 보고 확인하면 좋을 것 같다. 행동이 곧 역할을 정의하고, 역할이 곧 객체를 정의한다.

## 인터페이스

**인터페이스와 행동은 다르다**. 
인터페이스는 외부에서 어떤 객체에게 행동을 시키고자 할 때 메시지를 보낼 수 있는 창구일 뿐이다.
객체들끼리 서로 협력하려면 행동을 지시해야 하고, 필요에 따라 물어보기도 해야 할 것이다.

객체들이 인터페이스를 통해 통신하게 되면 객체 간의 결합도를 낮출 수 있다.
다 떠나서 인터페이스는 행동과 역할을 고민할 수 있게 도와준다.

## 행동과 역할

모델링을 할 때 행동에 대한 정의가 먼저 중요하다.


사고의 차이가 발생한 것은 '자동차'는 실체이고 '탈것'은 역할이기 때문이다.
실체에 집중할 때 데이터의 위주의 사고를 하고, 역할에 집중할 때 행동 위주의 사고를 한다.
왜냐하면 실체는 곧 구현이기 때문이다. 
메서드의 구현을 고민했더니 데이터 위주의 사고를 했던 것처럼 구현을 고민하는 것은 데이터 위주의 사고를 촉진한다.

실체만으로는 어떤 역할을 하는 클래스를 만들어달라는 것인지 알 수 없다.

따라서 '자동차 클래스를 만들어 줄 수 있나요?'같은 요청을 받았을 때 다음과 같은 질문을 역으로 했다면 더 좋았을 것이다.

- 자동차는 어떤 행동을 하는 객체인가요?
- 꼭 자동차이어야 하나요?
- 자동차라는 클래스를 만들어서 달성하려는 목표가 뭐지요?

클라이언트는 "탑승할 수 있고, 달릴 수 있으면 좋겠네요."라고 답할 수 있다.

그렇다면 그제야 클라이언트가 진짜로 원하는 것은 '탈것'이라는 사실을 알게 된다.

```java title="역할에 집중하면 행동이 나온다"
public interface Vehicle {
   
    void ride();
    void run();
    void stop();
}
```

반복적이고 의식적으로 객체가 어떤 행동을 해야 하는지 고민해야 한다. 
더 나아가 어떤 행동들을 모아 구조적으로 타당한 역할을 만들 수 있을지 계속해서 고민해야 한다.


## 메서드

어떤 객체나 시스템을 다루는 외부 세계는 협력 대상과 소통하기 위해 메시지를 이용한다.
객체는 협력 객체에 메시지를 건네고, 협력 객체는 메시지를 수신해서 행동을 하는 것이다.

객체지향에서 객체들은 메시지를 통해 소통합니다. 객체는 협력 객체에 메시지만 보낼 뿐이다.
실제는 어떤 방법(method)으로 일을 어떻게 처리할지는 객체가 정한다.
메서드란 어떤 메시지를 처리해 달라는 요청을 받았을 때 이를 어떻게 처리하는지 방법(method)을 서술하는 것이다.

객체지향에서 진짜 중요한 것은 책임을 나누고 메시지를 통해 협력 관계를 구축하는 것이다.

```java title="인터페이스를 통해 구현 객체가 무엇이냐에 따라 실행할 메서드가 달라진다."
class Car implements Vehicle { ... }
class Bicycle implements Vehicle { ... }

class User {

    void ride(Vehicle vehicle) {
        /// 코드가 실행되기 전까지는 알 수 없다.
        vehicle.ride();
    }
}
```